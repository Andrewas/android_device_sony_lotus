#       modified:   include/system/audio.h
#       modified:   include/system/graphics.h
#       modified:   adb/backup_service.c
#       modified:   adb/services.c
#       modified:   init/builtins.c
diff --git a/system/core/include/system/audio.h b/system/core/include/system/audio.h
index aa7ac02..3537e59 100644
--- a/system/core/include/system/audio.h
+++ b/system/core/include/system/audio.h
@@ -371,6 +371,24 @@ enum {
 
 typedef uint32_t audio_devices_t;
 
+#ifdef STE_AUDIO
+
+// AUDIO_INPUT_CLIENT_ID_BASE provide a means to refer to client Id´s not
+// explicitly defined in the enum audio_input_clients
+#define AUDIO_INPUT_CLIENT_ID_BASE AUDIO_INPUT_CLIENT_ID1
+
+// AUDIO_INPUT_CLIENT_ID_BASE provide a means to refer to client Id´s not explicitly defined
+// in the enum audio_input_clients
+typedef enum audio_input_clients {
+        AUDIO_INPUT_CLIENT_ID1 = 0x1,
+        AUDIO_INPUT_CLIENT_ID2 = 0x2,
+        AUDIO_INPUT_CLIENT_ID3 = 0x3,
+        AUDIO_INPUT_CLIENT_ID4 = 0x4,
+        AUDIO_INPUT_CLIENT_PLAYBACK = 0x80000000, // request client of playback type
+        AUDIO_INPUT_CLIENT_RECORD = 0x80000001   // request client of recording type
+} audio_input_clients;
+#endif
+
 /* the audio output flags serve two purposes:
  * - when an AudioTrack is created they indicate a "wish" to be connected to an
  * output stream with attributes corresponding to the specified flags
diff --git a/system/core/include/system/graphics.h b/system/core/include/system/graphics.h
index be86ae4..a3b464d 100644
--- a/system/core/include/system/graphics.h
+++ b/system/core/include/system/graphics.h
@@ -54,6 +54,8 @@ enum {
     HAL_PIXEL_FORMAT_RGB_888            = 3,
     HAL_PIXEL_FORMAT_RGB_565            = 4,
     HAL_PIXEL_FORMAT_BGRA_8888          = 5,
+    HAL_PIXEL_FORMAT_RGBA_5551          = 6,
+    HAL_PIXEL_FORMAT_RGBA_4444          = 7,
 
     /*
      * sRGB color pixel formats:
@@ -240,6 +242,23 @@ enum {
     HAL_PIXEL_FORMAT_YCbCr_422_I        = 0x14, // YUY2
 };
 
+enum {
+    /* STE: Added Support of YUV42XMBN, required for Copybit CC acceleration */
+    HAL_PIXEL_FORMAT_YCBCR42XMBN = 0xE,
+    /* Legacy formats (deprecated), used by ImageFormat.java */
+    HAL_PIXEL_FORMAT_YCbCr_422_P        = 0x12,
+    HAL_PIXEL_FORMAT_YCbCr_420_P        = 0x13,
+    HAL_PIXEL_FORMAT_YCbCr_420_I        = 0x15,
+    HAL_PIXEL_FORMAT_CbYCrY_422_I       = 0x16,
+    HAL_PIXEL_FORMAT_CbYCrY_420_I       = 0x17,
+    HAL_PIXEL_FORMAT_YCbCr_420_SP_TILED = 0x20,
+    HAL_PIXEL_FORMAT_YCbCr_420_SP       = 0x21,
+    HAL_PIXEL_FORMAT_YCrCb_420_SP_TILED = 0x22,
+    HAL_PIXEL_FORMAT_YCrCb_422_SP       = 0x23,
+    HAL_PIXEL_FORMAT_YCrCb_422_P        = 0x24,
+    HAL_PIXEL_FORMAT_YCrCb_420_P        = 0x25,
+};
+
 /*
  * Structure for describing YCbCr formats for consumption by applications.
  * This is used with HAL_PIXEL_FORMAT_YCbCr_*_888.
diff --git a/system/core/adb/backup_service.c b/system/core/adb/backup_service.c
index 669ff86..ae87c75 100644
--- a/system/core/adb/backup_service.c
+++ b/system/core/adb/backup_service.c
@@ -127,6 +127,7 @@ int backup_service(BackupOperation op, char* args) {
 
         // off we go
         execvp("/system/bin/bu", (char * const *)bu_args);
+        execvp("/sbin/bu", (char * const *)bu_args);
         // oops error - close up shop and go home
         fprintf(stderr, "Unable to exec 'bu', bailing\n");
         exit(-1);
diff --git a/system/core/adb/services.c b/system/core/adb/services.c
index f0d5878..6de18e2 100644
--- a/system/core/adb/services.c
+++ b/system/core/adb/services.c
@@ -258,8 +258,10 @@ static int create_subprocess(const char *cmd, const char *arg0, const char *arg1
 
 #if ADB_HOST
 #define SHELL_COMMAND "/bin/sh"
+#define ALTERNATE_SHELL_COMMAND ""
 #else
 #define SHELL_COMMAND "/system/bin/sh"
+#define ALTERNATE_SHELL_COMMAND "/sbin/sh"
 #endif
 
 #if !ADB_HOST
@@ -300,10 +302,19 @@ static int create_subproc_thread(const char *name)
     adb_thread_t t;
     int ret_fd;
     pid_t pid;
+    const char* shell_command;
+    struct stat filecheck;
+    if (stat(ALTERNATE_SHELL_COMMAND, &filecheck) == 0) {
+        shell_command = ALTERNATE_SHELL_COMMAND;
+    }
+    else {
+        shell_command = SHELL_COMMAND;
+    }
+
     if(name) {
-        ret_fd = create_subprocess(SHELL_COMMAND, "-c", name, &pid);
+        ret_fd = create_subprocess(shell_command, "-c", name, &pid);
     } else {
-        ret_fd = create_subprocess(SHELL_COMMAND, "-", 0, &pid);
+        ret_fd = create_subprocess(shell_command, "-", 0, &pid);
     }
     D("create_subprocess() ret_fd=%d pid=%d\n", ret_fd, pid);
 
diff --git a/system/core/init/builtins.c b/system/core/init/builtins.c
index e8c8f91..b33f4bd 100644
--- a/system/core/init/builtins.c
+++ b/system/core/init/builtins.c
@@ -15,6 +15,7 @@
  */
 
 #include <sys/types.h>
+#include <sys/wait.h>
 #include <sys/stat.h>
 #include <fcntl.h>
 #include <unistd.h>
@@ -35,6 +36,7 @@
 #include <cutils/android_reboot.h>
 #include <sys/system_properties.h>
 #include <fs_mgr.h>
+#include <fts.h>
 
 #include <selinux/selinux.h>
 #include <selinux/label.h>
@@ -240,7 +242,57 @@ int do_domainname(int nargs, char **args)
 
 int do_exec(int nargs, char **args)
 {
-    return -1;
+    pid_t pid;
+    int status, i, j;
+    char *par[MAX_PARAMETERS];
+    char prop_val[PROP_VALUE_MAX];
+    int len;
+
+    if (nargs > MAX_PARAMETERS)
+    {
+        return -1;
+    }
+
+    for(i=0, j=1; i<(nargs-1) ;i++,j++)
+    {
+        if ((args[j])
+            &&
+            (!expand_props(prop_val, args[j], sizeof(prop_val))))
+
+        {
+            len = strlen(args[j]);
+            if (strlen(prop_val) <= len) {
+                /* Overwrite arg with expansion.
+                 *
+                 * For now, only allow an expansion length that
+                 * can fit within the original arg length to
+                 * avoid extra allocations.
+                 * On failure, use original argument.
+                 */
+                strncpy(args[j], prop_val, len + 1);
+            }
+        }
+        par[i] = args[j];
+    }
+
+    par[i] = (char*)0;
+    pid = fork();
+    if (!pid)
+    {
+        char tmp[32];
+        int fd, sz;
+        get_property_workspace(&fd, &sz);
+        sprintf(tmp, "%d,%d", dup(fd), sz);
+        setenv("ANDROID_PROPERTY_WORKSPACE", tmp, 1);
+        execve(par[0], par, environ);
+        exit(0);
+    }
+    else
+    {
+        while(wait(&status)!=pid);
+    }
+
+    return 0;
 }
 
 int do_export(int nargs, char **args)
